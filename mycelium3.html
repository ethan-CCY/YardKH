<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互動式菌絲生長 (滑鼠退縮版)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            cursor: crosshair; /* 改變游標形狀提示可互動 */
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            color: #fff;
            transition: opacity 0.3s;
            opacity: 0.2;
            z-index: 10;
            user-select: none; /* 防止拖拉時選取文字 */
        }

        #controls:hover {
            opacity: 1;
        }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        label {
            font-size: 14px;
            margin-right: 10px;
            min-width: 90px;
        }

        input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 8px;
            background-color: #2a9d8f;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }

        button:hover {
            background-color: #21867a;
        }
    </style>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <label>生長速度</label>
            <input type="range" id="speedRaw" min="1" max="10" value="3">
        </div>
        <div class="control-group">
            <label>線條粗細</label>
            <input type="range" id="thicknessRaw" min="0.5" max="8" step="0.5" value="2">
        </div>
        <div class="control-group">
            <label>分支機率</label>
            <input type="range" id="branchRaw" min="1" max="10" value="2">
        </div>
        <div class="control-group">
            <label>淡出速度</label>
            <input type="range" id="fadeRaw" min="1" max="15" value="3" title="數值越小，保留越久">
        </div>
        <div class="control-group" style="border-top: 1px solid #555; padding-top: 10px;">
            <label>滑鼠影響範圍</label>
            <input type="range" id="mouseRadiusRaw" min="20" max="200" value="80">
        </div>
        <button onclick="resetSimulation()">重新生長</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let particles = [];
        let hue = 0;
        
        // 滑鼠物件
        let mouse = {
            x: null,
            y: null,
            radius: 80 // 影響半徑
        };

        // 設定參數
        let config = {
            speed: 3,
            thickness: 2,
            branchProb: 0.02,
            fadeSpeed: 0.03,
            maxParticles: 800 // 限制最大粒子數以免卡頓
        };

        // 綁定 UI 控制項
        const speedInput = document.getElementById('speedRaw');
        const thickInput = document.getElementById('thicknessRaw');
        const branchInput = document.getElementById('branchRaw');
        const fadeInput = document.getElementById('fadeRaw');
        const mouseRadiusInput = document.getElementById('mouseRadiusRaw');

        // 事件監聽
        speedInput.oninput = () => config.speed = parseFloat(speedInput.value);
        thickInput.oninput = () => config.thickness = parseFloat(thickInput.value);
        branchInput.oninput = () => config.branchProb = parseFloat(branchInput.value) / 100;
        fadeInput.oninput = () => config.fadeSpeed = parseFloat(fadeInput.value) / 100;
        mouseRadiusInput.oninput = () => mouse.radius = parseFloat(mouseRadiusInput.value);

        // --- 滑鼠事件監聽 ---
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // 滑鼠離開視窗時，重置位置，避免橡皮擦卡在邊緣
        canvas.addEventListener('mouseleave', () => {
            mouse.x = null;
            mouse.y = null;
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            resetSimulation();
        }
        window.addEventListener('resize', resize);

        class Particle {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.active = true;
                this.life = 0;
            }

            update() {
                if (!this.active) return;

                // --- 滑鼠互動核心邏輯 ---
                // 如果滑鼠在畫布上，計算距離
                if (mouse.x !== null && mouse.y !== null) {
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    // 使用平方距離比較，效能較好 (避免開根號)
                    const distanceSq = dx * dx + dy * dy;
                    
                    // 如果距離小於設定半徑，粒子死亡 (停止生長)
                    if (distanceSq < mouse.radius * mouse.radius) {
                        this.active = false;
                        // 選擇性特效：可以在這裡加一個小爆炸或變色，但直接消失最符合「退縮」
                        return; // 直接結束這一幀的處理
                    }
                }
                // -----------------------

                const lx = this.x;
                const ly = this.y;

                this.x += Math.cos(this.angle) * config.speed;
                this.y += Math.sin(this.angle) * config.speed;

                // 有機擺動
                this.angle += (Math.random() - 0.5) * 0.5;

                this.life++;

                // 邊界檢查
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.active = false;
                }

                // 繪製線段
                ctx.beginPath();
                ctx.moveTo(lx, ly);
                ctx.lineTo(this.x, this.y);
                ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
                ctx.lineWidth = config.thickness;
                ctx.lineCap = 'round';
                ctx.stroke();

                // 分支邏輯
                if (this.active && Math.random() < config.branchProb) {
                    if (particles.length < config.maxParticles) { 
                        this.branch();
                    }
                }

                // 隨機自然消亡
                if (this.life > 150 && Math.random() < 0.02) {
                    this.active = false;
                }
            }

            branch() {
                const deviation = (Math.random() - 0.5) * 1.5; 
                particles.push(new Particle(this.x, this.y, this.angle + deviation));
            }
        }

        function resetSimulation() {
            particles = [];
            hue = Math.random() * 360;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i;
                particles.push(new Particle(centerX, centerY, angle));
            }
        }

        function animate() {
            // 淡出效果層
            ctx.fillStyle = `rgba(0, 0, 0, ${config.fadeSpeed})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            hue += 0.5;

            // 更新粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (!particles[i].active) {
                    particles.splice(i, 1);
                }
            }

            // 自動補給機制：如果被滑鼠清光了，從中心重生
            if (particles.length < 5) {
               const centerX = canvas.width / 2;
               const centerY = canvas.height / 2;
               // 只有當滑鼠不在中心點附近時才重生，不然一出來又被消滅
               let safeToSpawn = true;
               if (mouse.x !== null) {
                   const dx = mouse.x - centerX;
                   const dy = mouse.y - centerY;
                   if (dx*dx + dy*dy < mouse.radius * mouse.radius) {
                       safeToSpawn = false;
                   }
               }

               if (safeToSpawn) {
                   for(let k=0; k<3; k++) {
                       particles.push(new Particle(centerX, centerY, Math.random() * Math.PI * 2));
                   }
               }
            }

            requestAnimationFrame(animate);
        }

        // 初始化
        resize();
        animate();

    </script>
</body>

</html>
//分支設定測試
